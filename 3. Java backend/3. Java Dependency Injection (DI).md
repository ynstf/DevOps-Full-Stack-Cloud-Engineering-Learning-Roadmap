# ğŸ’‰ Java Dependency Injection (DI) - Practical & Interview-Focused Guide

## ğŸ“Œ Overview

Dependency Injection (DI) is a design pattern that allows components to be loosely coupled by injecting dependencies externally rather than creating them internally.

This guide will teach you:

* ğŸ§  Theoretical principles of DI
* ğŸ’» Practical implementations with Google Guice
* ğŸ§ª Real-world examples
* ğŸ› ï¸ Refactoring tight coupling
* ğŸ§© Interface-based decoupling

---

## 1ï¸âƒ£ What is Dependency Injection?

### ğŸ§  Concept

Dependency Injection moves object creation outside of a class and hands it in from an external source (like a framework).

### âŒ Tight Coupling Example

```java
public class JobQueue {
    private EmailNotifier notifier = new EmailNotifier(); // tight coupling
}
```

### âœ… Loose Coupling with DI

```java
public class JobQueue {
    private final Notifier notifier;

    @Inject
    public JobQueue(Notifier notifier) {
        this.notifier = notifier;
    }
}
```

---

## 2ï¸âƒ£ Why Use DI?

### ğŸ¯ Benefits

* Easy to **swap implementations** (Email â†’ SMS)
* Simplified **unit testing** with mocks
* Encourages **separation of concerns**

### âŒ Problem without DI

```java
EmailNotifier emailNotifier = new EmailNotifier();
JobQueue jobQueue = new JobQueue(); // cannot inject emailNotifier
```

### âœ… With DI (Mocking Enabled)

```java
Notifier mockNotifier = Mockito.mock(Notifier.class);
JobQueue queue = new JobQueue(mockNotifier);
```

---

## 3ï¸âƒ£ Introducing Google Guice

### ğŸ§  Concept

Google Guice is a lightweight DI framework that uses annotations and modules.

### âœ… Steps to Use:

1. Annotate constructors with `@Inject`
2. Define dependencies in `@Provides` methods
3. Use `Modules` and `Injectors`

---

## 4ï¸âƒ£ Step-by-Step with Guice

### ğŸ”§ Step 1: Create Dependencies

```java
public class Engine {}

public class Car {
    private final Engine engine;

    @Inject
    public Car(Engine engine) {
        this.engine = engine;
    }
}
```

### ğŸ”§ Step 2: Create Module

```java
public class CarModule extends AbstractModule {
    @Provides
    Engine provideEngine() {
        return new Engine();
    }
}
```

### ğŸ”§ Step 3: Build Injector

```java
Injector injector = Guice.createInjector(new CarModule());
Car car = injector.getInstance(Car.class);
```

---

## 5ï¸âƒ£ Refactoring JobQueue Example

### Original (Tightly Coupled)

```java
public class JobQueue {
    private final EmailNotifier emailNotifier = new EmailNotifier();
    public void addJob(Job job) {
        emailNotifier.notify(job);
    }
}
```

### Refactored with DI

```java
public interface Notifier {
    void notify(Job job);
}

public class EmailNotifier implements Notifier {
    public void notify(Job job) {
        // send email
    }
}

public class JobQueue {
    private final Notifier notifier;

    @Inject
    public JobQueue(Notifier notifier) {
        this.notifier = notifier;
    }
    public void addJob(Job job) {
        notifier.notify(job);
    }
}
```

---

## 6ï¸âƒ£ Module with Binding

```java
public class JobQueueModule extends AbstractModule {
    @Override
    protected void configure() {
        bind(Notifier.class).to(EmailNotifier.class);
    }
}
```

### Using Injector

```java
Injector injector = Guice.createInjector(new JobQueueModule());
JobQueue jobQueue = injector.getInstance(JobQueue.class);
```

---

## ğŸ§ª Real-World Example: Swappable Notifier

### Add a Slack Notifier

```java
public class SlackNotifier implements Notifier {
    public void notify(Job job) {
        // send to Slack
    }
}
```

### Swap in the Module

```java
bind(Notifier.class).to(SlackNotifier.class);
```

ğŸ¯ Result: Your code never changes â€” only the binding changes.

---

## ğŸ§© DI with Unit Testing (Mockito)

```java
Notifier mockNotifier = Mockito.mock(Notifier.class);
JobQueue queue = new JobQueue(mockNotifier);

queue.addJob(new Job("123"));
Mockito.verify(mockNotifier, times(1)).notify(any());
```

âœ… Now testing is independent of the actual notifier!

---

## âš™ï¸ DI System Diagram

```
[Module] â†’ defines â†’ [Dependency Mapping] â†’ injected by â†’ [Injector] â†’ builds â†’ [Your Class]
```

---

## â“ Interview Q\&A

* **Q: What is the purpose of DI?**
  A: To reduce tight coupling and improve testability and flexibility.

* **Q: How does Guice inject dependencies?**
  A: Via `@Inject` and `@Provides`, and resolves via `Injector.getInstance()`.

* **Q: What is the difference between `@Provides` and `bind()`?**
  A:

  * `@Provides` returns an actual instance.
  * `bind()` links interface to a class.

* **Q: Can you inject mocks for testing?**
  A: Yes, by manually instantiating with mocks or using test modules.

---

## âœ… Practice Checklist

* [ ] Create a simple service with a dependency
* [ ] Refactor to inject via constructor with `@Inject`
* [ ] Bind interface to implementation
* [ ] Write a test with Mockito and inject a mock
* [ ] Swap out implementations via Module

---

ğŸ“š For Further Learning

* [Google Guice Docs](https://github.com/google/guice/wiki/Motivation)
* [Dependency Injection - Baeldung](https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring)

ğŸ¯ **Use DI to simplify your architecture and make testing & maintenance easier.**
