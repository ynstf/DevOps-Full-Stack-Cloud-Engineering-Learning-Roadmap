# ğŸš€ Java Streams API - Practical & Interview-Ready Guide

## ğŸ“Œ Overview

Java Streams API is a modern, declarative way to process collections using a fluent interface. This guide covers:

* ğŸ§  Theoretical concepts
* ğŸ’» Full command and method examples
* ğŸ§ª Real-world use cases
* ğŸ“Š Diagram-style flow explanations
* â“ Interview-ready insights

---

## 1ï¸âƒ£ What Is a Stream?

### ğŸ§  Concept

A **Stream** is a sequence of elements supporting sequential and parallel operations. Unlike collections, it doesnâ€™t store data but conveys it through a pipeline of transformations.

```
Source (List/Set) â†’ Intermediate Ops (map/filter) â†’ Terminal Op (collect/count)
```

---

## 2ï¸âƒ£ Creating Streams

### âœ… From Collections

```java
List<String> names = List.of("Alice", "Bob", "Charlie");
Stream<String> stream = names.stream();
```

### âœ… From Values

```java
Stream<Integer> numbers = Stream.of(1, 2, 3, 4);
```

### âœ… Infinite Streams

```java
Stream<Double> randoms = Stream.generate(Math::random).limit(5);
```

---

## 3ï¸âƒ£ Intermediate Operations (Lazy)

These return a new stream and are only triggered when a terminal operation is called.

### ğŸ”¹ `filter(Predicate<T>)`

```java
cars.stream()
    .filter(car -> car.getType().equals("sedan"))
    .collect(Collectors.toList());
```

### ğŸ”¹ `map(Function<T,R>)`

```java
cars.stream()
    .map(Car::getMake)
    .collect(Collectors.toList());
```

### ğŸ”¹ `flatMap(Function<T, Stream<R>>)`

```java
cars.stream()
    .flatMap(car -> Stream.of(car.getMake(), car.getModel()))
    .collect(Collectors.toList());
```

### ğŸ”¹ `distinct()`, `sorted()`, `limit(n)`

```java
numbers.stream()
    .distinct()
    .sorted()
    .limit(5)
    .collect(Collectors.toList());
```

---

## 4ï¸âƒ£ Terminal Operations (Trigger Execution)

### ğŸ”¹ `collect()`

```java
List<String> names = stream.collect(Collectors.toList());
Set<String> unique = stream.collect(Collectors.toSet());
```

### ğŸ”¹ `count()`, `min()`, `max()`

```java
long total = cars.stream().count();
```

### ğŸ”¹ `forEach()`

```java
cars.stream().forEach(System.out::println);
```

### ğŸ”¹ `reduce()`

```java
int sum = Stream.of(1, 2, 3).reduce(0, Integer::sum);
```

### ğŸ”¹ `anyMatch()`, `allMatch()`

```java
boolean allSedans = cars.stream()
    .allMatch(car -> car.getType().equals("sedan"));
```

---

## 5ï¸âƒ£ Collectors Deep Dive

### ğŸ”¹ Grouping

```java
Map<String, List<Car>> byType = cars.stream()
    .collect(Collectors.groupingBy(Car::getType));
```

### ğŸ”¹ Partitioning (Boolean Key)

```java
Map<Boolean, List<Car>> partitions = cars.stream()
    .collect(Collectors.partitioningBy(car -> car.getType().equals("sedan")));
```

### ğŸ”¹ Mapping Inside Grouping

```java
Map<String, Map<String, Integer>> grouped = cars.stream()
    .collect(Collectors.groupingBy(Car::getType,
        Collectors.toMap(Car::getMake, Car::getEngineCapacity)));
```

---

## 6ï¸âƒ£ Stream Execution Model (Lazy Evaluation)

### ğŸ§  Key Concept

No transformation runs until a terminal operation is invoked. Intermediate operations are fused for performance.

```java
Stream<String> filtered = names.stream()
    .filter(name -> name.startsWith("A"));

// Nothing happens yet until:
long count = filtered.count();
```

---

## 7ï¸âƒ£ Parallel Streams

```java
cars.parallelStream()
    .map(Car::getModel)
    .forEach(System.out::println);
```

* Automatically splits workload across available cores
* Use `.sequential()` to revert back

---

## ğŸ§ª Real-World Example: Filtering & Mapping Cars

```java
List<String> makes = cars.stream()
    .filter(c -> c.getType().equals("sedan"))
    .map(Car::getMake)
    .distinct()
    .sorted()
    .collect(Collectors.toList());
```

ğŸ¯ Output: Sorted, unique makes of all sedans

---

## ğŸ“Š Comparison Chart

| Operation | Type         | Returns  | Lazy? |
| --------- | ------------ | -------- | ----- |
| filter    | Intermediate | Stream   | âœ…     |
| map       | Intermediate | Stream   | âœ…     |
| flatMap   | Intermediate | Stream   | âœ…     |
| collect   | Terminal     | List/Set | âŒ     |
| forEach   | Terminal     | void     | âŒ     |
| count     | Terminal     | long     | âŒ     |

---

## â“ Interview Q\&A

* **Q: Difference between map and flatMap?**
  A: `map` transforms 1:1; `flatMap` transforms and flattens nested structures.

* **Q: What makes Streams lazy?**
  A: Intermediate operations are queued until a terminal op is called.

* **Q: When to use `groupingBy` vs `partitioningBy`?**
  A: `groupingBy` uses any key; `partitioningBy` is Boolean-based.

* **Q: How is parallelStream different?**
  A: It runs on multiple threads using ForkJoinPool.

---

## âœ… Practice Checklist

* [ ] Use `filter` to extract items
* [ ] Use `map` to transform values
* [ ] Chain `map`, `filter`, `collect`
* [ ] Create nested grouping with `Collectors.groupingBy()`
* [ ] Write a `parallelStream` processing function

---

ğŸ“š For Further Study:

* [Java Docs - Stream](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)
* [Baeldung Java Stream Guide](https://www.baeldung.com/java-8-streams)

