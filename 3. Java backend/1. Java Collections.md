# ğŸ“š Java Collections - Interview-Focused, Practical Guide

## ğŸ“Œ Overview

Java Collections are a powerful framework that allows developers to store, retrieve, and manipulate groups of objects efficiently. This guide provides:

* ğŸ§  Detailed theoretical explanations
* ğŸ’» API usage and commands (via method examples)
* ğŸ§ª Real-world code demonstrations
* ğŸ“Š Diagrams and time complexity insights

Perfect for interviews and production-ready development.

---

## 1ï¸âƒ£ Collection Hierarchy in Java

### ğŸ§  Concept

Java Collections are built on a hierarchy of interfaces and classes.

```
Iterable
  â””â”€â”€ Collection
       â”œâ”€â”€ List (ArrayList, LinkedList)
       â”œâ”€â”€ Set (HashSet, TreeSet, LinkedHashSet)
       â””â”€â”€ Queue (PriorityQueue, LinkedList)
```

Each interface provides a contract, and implementing classes offer specific behaviors and performance.

---

## 2ï¸âƒ£ List Interface: ArrayList vs LinkedList

### ğŸ”¸ ArrayList

* Backed by a resizable array
* Fast random access (O(1))
* Slow insert/delete at arbitrary positions (O(n))

### âœ… Useful Methods

```java
list.add("A");
list.remove("A");
list.get(0);
list.contains("B");
list.clear();
```

### ğŸ§ª Example

```java
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
System.out.println(names.get(0)); // Alice
```

### ğŸ¯ Use Case

Display a list of users where insertions happen at the end and random reads are common.

---

### ğŸ”¸ LinkedList

* Doubly linked nodes
* Fast insert/delete (O(1)) at ends
* Slower access by index (O(n))

### âœ… Useful Methods

```java
linkedList.addFirst("A");
linkedList.addLast("B");
linkedList.poll(); // remove from front
linkedList.offer("C"); // add to rear
```

### ğŸ§ª Queue + Stack

```java
Queue<String> queue = new LinkedList<>();
queue.offer("1"); queue.offer("2");
System.out.println(queue.poll()); // 1

Deque<String> stack = new LinkedList<>();
stack.push("A"); stack.push("B");
System.out.println(stack.pop()); // B
```

### ğŸ¯ Use Case

Order processing (FIFO) or backtracking algorithms (LIFO).

---

## 3ï¸âƒ£ PriorityQueue

### ğŸ§  Concept

* Heap-based queue
* Retrieves elements by priority (natural or comparator-defined)

### âœ… Useful Methods

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(5); pq.offer(2); pq.offer(8);
System.out.println(pq.poll()); // 2
```

### ğŸ§ª Custom Object

```java
PriorityQueue<User> pq = new PriorityQueue<>(
    Comparator.comparingInt(User::getAge)
);
```

### ğŸ¯ Use Case

Task scheduling, leaderboards, message priority systems.

---

## 4ï¸âƒ£ HashMap and TreeMap

### ğŸ”¸ HashMap

* Key-value pair storage
* Fast O(1) lookup with hashing
* Unordered

### âœ… Useful Methods

```java
map.put("id1", "John");
map.get("id1");
map.containsKey("id2");
map.keySet();
map.values();
```

### ğŸ§ª Example

```java
Map<String, String> users = new HashMap<>();
users.put("admin", "Alice");
System.out.println(users.get("admin"));
```

### ğŸ¯ Use Case

Session management, cache storage, ID mapping.

---

### ğŸ”¸ TreeMap

* Sorted map
* Backed by Red-Black Tree
* O(log n) insert and lookup

### âœ… Custom Order

```java
TreeMap<String, Integer> sortedMap = new TreeMap<>();
sortedMap.put("C", 3);
sortedMap.put("A", 1);
sortedMap.put("B", 2);
```

### ğŸ¯ Use Case

Leaderboard, financial tickers, alphabetical catalog.

---

## 5ï¸âƒ£ Set Interface

### ğŸ”¸ HashSet

* Backed by HashMap
* Unordered
* No duplicates

```java
Set<String> tags = new HashSet<>();
tags.add("java"); tags.add("spring");
```

### ğŸ”¸ LinkedHashSet

* Maintains insertion order

### ğŸ”¸ TreeSet

* Sorted
* Based on TreeMap

```java
Set<String> sortedTags = new TreeSet<>();
sortedTags.add("c"); sortedTags.add("a");
```

### ğŸ¯ Use Case

Avoiding duplicates in permissions, product SKUs, hashtags.

---

## 6ï¸âƒ£ Collections Utility Methods

### âœ… Sorting & Searching

```java
Collections.sort(list);
Collections.binarySearch(list, "item");
```

### âœ… Stats

```java
Collections.frequency(list, "A");
Collections.max(list);
Collections.min(list);
```

### âœ… Shuffle, Replace, Swap

```java
Collections.shuffle(list);
Collections.swap(list, 0, 1);
Collections.replaceAll(list, "old", "new");
```

### ğŸ¯ Use Case

Shuffling quiz questions, replacing status values, sorting leaderboard.

---

## 7ï¸âƒ£ Thread Safety

### ğŸ§  Problem:

Collections are not thread-safe by default.

### âœ… Solutions

```java
List<String> safeList = Collections.synchronizedList(new ArrayList<>());
Set<String> safeSet = Collections.synchronizedSet(new HashSet<>());
```

### ğŸ¯ Use Case

Shared collection in a multithreaded application.

---

## ğŸ“Š Time Complexity Comparison Chart

| Collection Type | Access   | Insert   | Remove   |
| --------------- | -------- | -------- | -------- |
| ArrayList       | O(1)     | O(1)\*   | O(n)     |
| LinkedList      | O(n)     | O(1)     | O(1)     |
| HashMap         | O(1)     | O(1)     | O(1)     |
| TreeMap         | O(log n) | O(log n) | O(log n) |
| HashSet         | O(1)     | O(1)     | O(1)     |
| TreeSet         | O(log n) | O(log n) | O(log n) |
| PriorityQueue   | â€”        | O(log n) | O(log n) |

> \*Amortized for ArrayList

---

## â“ Interview Q\&A

* **Q: Difference between ArrayList and LinkedList?**
  A: ArrayList is fast at random access, LinkedList is better for inserts/deletes.

* **Q: Why use TreeMap over HashMap?**
  A: TreeMap maintains order of keys.

* **Q: How to make a synchronized collection?**
  A: Use `Collections.synchronizedX()` methods.

* **Q: What happens if you insert duplicate into HashSet?**
  A: It is ignored.

